## Kubernetes

> Перед прочтением этого гайда обязательно ознакомьтесь с guide_docker.md, так как контейнеры - это основа Kubernetes.

Kubernetes - это платформа для декларативного управления контейнеризированными приложениями. Декларативность достигается за счет того, что вся конфигурация описывается в .yaml файлах (объекты Kubernetes), далее эти файлы передаются в кластер Kubernetes, и он сам заботится а том, чтобы кластер пришел к описанному в файле состоянию. Благодаря этому, становится возможным удобно управлять и масштабировать большие системы, построенные на микросервисной архитектуре.

[Видео](https://www.youtube.com/watch?v=QR_6Lvr3JSI) про Kubernetes

## Теория

Чтобы лучше понять, что такое микросервисы, надо знать основные виды архитектур:
1. <b>Монолотное приложение</b> - одно огромное приложение, над которым могут работать одна или несколько команд. Деплоится системными администраторами на один виртуальный или физический сервер. Если нагрузка на приложение высокая, и нужно его масштабировать, то деплоится полная копия этого приложения на другой сервер, и балансировщик нагрузки (легковесное приложение, основная задача которого - распределять трафик) передает им запросы. Это классический подход, именно такое приложение мы писали на Предпроекте. Подходит для небольших систем, но ужасно неудобно для больших.
2. <b>Сервис-ориентированная архитектура (SOA)</b> - огромный монолит дробится на меньшие модули, так называемые сервисы. Сервисы общаются друг с другом посредством REST, RPC, брокеров сообщений (Kafka). Над одним сервисом может работать как одна, так и несколько команд. Деплоится по-прежнему на виртуальные/физические серверы, но теперь этих серверов нужно гораздо больше, и нужны опытные системные администраторы, которые будут управлять и поддерживать всю эту систему. Масштабируется таким же образом, как и монолит. Подходит для больших систем, но для по-настоящему огромных и высоконагруженных был придуман следующий подход.
3. <b>Микросервисная архитектура</b> - так же, как в SOA, каждый микросервис отвечает за свою часть логики общей системы, но сервисы SOA дробятся на еще более мелкие модули, микросервисы, отсюда приставка 'микро'. Общаются микросервисы друг с другом так же, как и сервисы SOA. Один микросервис разрабатывается одной командой, при этом одна команда может разрабатывать несколько микросервисов. В отличие от предыдущих подходов, деплоем и управлением отведенным команде микросервисом занимается сама команда разработки (DevOps подход), отсюда вытекает необходимость разбираться в основах Kubernetes. Отдельные же специалисты, DevOps-инженеры, обычно занимаются управлением и поддержкой кластера Kubernetes целиком (кто-то же должен его еще развернуть). Масштабирование более прсстое и гибкое, чем в предыдущих подходах: достаточно одной команды или нескольких кликов (если работать через UI), либо можно настроить автоматическое масштабирование системы в случае увеличения нагрузки, и такое же автоматическое уменьшение количества реплик приложения, чтобы не тратить ресурсы, если нагрузка прошла, а Kubernetes сам займется распределением трафика. Важно отметить, что эта арихтектура подходит только очень крупным компаниям с большими нагрузками, при которых раскрываются преимущества такого гибкого масштабирования, например, крупным банкам. Небольшим компаниями микросервисы принесут только головную боль и лишние расходы, если нет опытных специалистов, способных эффективно поддерживать кластер Kubernetes.

> Несмотря на то, микросервисы можно писать и не на Kubernetes (например, на SpringCloud, которому посвящена значительная часть курса Advanced на платформе), микросервисы и Kubernetes стали практически тождественными понятиями, так как сейчас Kubernetes - это абсолютный стандарт построения микросервисов. При устройстве на работу, понимание Kubernetes и умение с ним работать, дает значительное преимущество над кандидатами без такого опыта.

##  Основные объекты Kubernetes:
<ul>
<li><b>Pod</b> - основная единица исполнения Kubernetes. Внутри Pod может быть один и более контейнер. Например, внутри Pod, в одном контейнере будет работать наше приложение, а во втором - вспомогательное приложение, которое будет собирать логи с нашего основного приложения и отправлять их в единое место для хранения и дальнейшего анализа (fluentbit). Обычно Pod самостоятельно не создается, его создает ReplicaSet.</li>
<li><b>ReplicaSet</b> - контролирует количество запущенных Pod одного типа (одного микросервиса). Это основной инструмент масштабирования приложений в Kubernetes. Обычно самостоятельно не создается, его создает Deployment.</li>
<li><b>Deployment</b> - абстракция над Pod и ReplicaSet, которая позволяет описать, как Kubernetes должен создать Pod: какой образ использовать, сколько реплик этого Pod следует создать, какие порты должны быть открытыми и др. Если разработчик хочет развернуть новый микросервис, то он должен создать Deployment, чтобы поднять Pod'ы, и Service, чтобы к этим Pod'ам можно было обратиться.</li>
<li><b>Service</b> - когда создается Pod, ему присваивается IP, и другие Pod'ы могут обращаться к этой Pod'е по ее IP. Однако Pod'ы постоянно умирают и поднимаются заново, и каждый раз им присваивается новый IP, поэтому существует Service. Service позволяет обращаться к Pod'ам одного типа по сатическому человекочитаемому названию, по сути это домен. Существует несколько типов Service:</li>

- ClusterIP - дефолтный тип сервиса. Используется для маршрутизации трафика внутри кластера.
- NodePort - позволяет обратиться к Pod извне кластера по IP ноды и выделенному порту (Node - один из серверов, на которых развернут Kubernetes. Их всегда несколько, и вместе они формируют кластер Kubernetes). Если IP ноды поменяется, то обратиться к Pod'е по старому адресу будет невозможно, придется уведомлять пользователей о новом IP. По этой причине этот тип сервиса редко используется.
- LoadBalancer - более удобный аналог NodePort, позволяет обратиться к Pod извне кластера по постоянному выделенному IP, без порта. Если требуется предоставить публичный доступ к нескольким микросервисам (Pod'ам разного типа), то придется создавать несколько LoadBalancer, что неудобно и сопряжено с дополнительными расходами.
<li><b>Ingress</b> - аналог Service типа LoadBalancer, но без его недостатков. Один Ingress может перенаправить трафик на сколько угодно Service, которые в свою очередь перенаправят его на соответствующие Pod'ы. Именно эти объекты используют, чтобы предоставить доступ к нашим микросервисам конечному пользователю.
<li><b>ConfigMap</b> - объект, в котором можно хранить и передавать нужную приложению информацию. Например, для микросервисов на спринге в ConfigMap обычно выносят application.yml. Это удобно, потому что можно поменять настройки application.yml внутри ConfigMap, перезагрузить Pod'у с приложением, и после ее перезапуска оно получит обновленную кофигурацию. Иначе нам бы пришлось полностью пересобирать приложение, менять его образ в Deployment и заново деплоить.</li>
<li><b>Secret</b> - аналог ConfigMap, но для конфиденциальной информации, например, пароль от БД. Информация хранится в закодированном в base64 виде. Однако чтобы информация была действительно обезопасена, нужно использовать сторонние инструменты для шифрования.</li>
</ul>

[Видео](https://www.youtube.com/watch?v=6HIXuufbdtk) про некоторые из упомянутых объектов

